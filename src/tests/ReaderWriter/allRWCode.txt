/**
 * testReaderWriter.cpp contains the code to run the Readers-Writers Problem animation using TSGL and POSIX threads.
 * The program utilizes Reader and Writer classes as well as a custom monitor class to hold the shared data.
 * Usage: ./testReaderWriter [numberOfReaders] [numberOfWriters] [preference]
 * [preference] can be 'w' for writer priority or 'r' for reader priority and defaults to writer priority
 */

//#include <omp.h>
//#include <tsgl.h>
#include <unistd.h>
#include <cassert> // assert
#include "ReaderWriter/Reader.h"
#include "ReaderWriter/Writer.h"
#include "ReaderWriter/ColorItem.h"
#include "ReaderWriter/RWMonitor.h"
#include "ReaderWriter/WMonitor.h"
#include "ReaderWriter/RMonitor.h"
#include "../TSGL/tsgl.h"
#include "../TSGL/Canvas.h"
#include "../TSGL/Line.h"
using namespace tsgl;

//Constants
const int WINDOW_WIDTH = 600, WINDOW_HEIGHT = 800, MARGIN = 45; //Size of Canvas and margin around data

int main(int argc, char* argv[]) {

	//Number of readers is the first argument or defaults to 4
	int numReaders  = ( (argc > 1) && (atoi(argv[1]) > 0) && (atoi(argv[1]) <= 8) ) ? atoi(argv[1]) : 4;
	//Number of writers is the second argument or defaults to 4
	int numWriters = ( (argc > 2) && (atoi(argv[2]) > 0) && (atoi(argv[2]) <= 8) ) ? atoi(argv[2]) : 4;
	
	//Start Reader-Writer visualization
	Canvas can(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT, "Reader-Writer", 1.0f/2);  //Canvas to draw on

	//Create monitor
	RWMonitor<ColorItem> * monitor;
	string lockString; //String description of lock style
	int max = floor(200 / ColorItem::width) * floor(600 / ColorItem::width);
	if( argc > 3 && *argv[3] == 'r' ) { //Create Reader preference Monitor
		monitor = new RMonitor<ColorItem>(max);
		lockString = "Reader priority";
	} else {							//Create Writer preference Monitor
		monitor = new WMonitor<ColorItem>(max);
		lockString = "Writer priority";
	}

	srand(time(NULL)); //Seed random number generator for colors and wait times

	Reader * readers = new Reader[numReaders]; //Array of Readers
	Writer * writers = new Writer[numWriters]; //Array of Writers

	//Start the visualization
	can.start();
	can.setBackgroundColor(WHITE);

	//Draw labels
	can.drawRectangle(ColorItem::dataX-MARGIN, WINDOW_HEIGHT/12, WINDOW_WIDTH*2/3+MARGIN, ColorItem::dataY, GRAY, true); // draw data area
	can.drawText(lockString, 50, WINDOW_HEIGHT-50, 20, BLACK);
	can.drawText("Numbers indicate", WINDOW_WIDTH-225, WINDOW_HEIGHT-50, 20, BLACK);
	can.drawText("counts of reads/writes", WINDOW_WIDTH-225, WINDOW_HEIGHT-30, 20, BLACK);
	can.drawText("Writers", 20, 20, 20, BLACK);
	can.drawText("Readers", WINDOW_WIDTH-150, 20, 20, BLACK);

	//Fill the Reader and Writer arrays with their objects
	for(int i = 0; i < numReaders; i++) {
		readers[i] = Reader(*monitor, i, can); //Reader created
	}
	for(int i = 0; i < numWriters; i++) {
		writers[i] = Writer(*monitor, i, can); //Writer created
	}

	//Start the Reader and Writer pthreads
	for(int i = 0; i < numWriters; i++) {
		writers[i].start();
		sleep(0.1);
	}
	sleep(1);
	for(int i = 0; i < numReaders; i++) {
		readers[i].start();
		sleep(0.1);
	}

	can.wait(); //Wait for the main Canvas to be closed

	//End threads
	for(int i = 0; i < numReaders; i++) {
		readers[i].join();
	}
	for(int i = 0; i < numWriters; i++) {
		writers[i].join();
	}

	//Cleanup
	delete [] readers;
	delete [] writers;
	readers = NULL;
	writers = NULL;

	return 0;
}
/**
 * ColorItem.h provides a ColorItem class for the Reader-Writer visualization.
 * ColorItem is a drawable object with a color, Canvas, and coordinates.
 */

#ifndef COLORITEM_H_
#define COLORITEM_H_

//#include <tsgl.h>
#include "../../TSGL/tsgl.h"
using namespace tsgl;


class ColorItem {
public:
	ColorItem(); //Default constructor
	ColorItem(Canvas & can, ColorInt color, int index);
	ColorItem& operator=(const ColorItem& original);
	bool operator==(ColorItem& original);
	int getX() { return myX; } 				//Access item's x coordinate
	int getY() { return myY; } 				//Access item's y coordinate
	int getId() { return myId; } 			//Access item's id
	ColorInt getColor() { return myColor; } //Access stored ColorInt
	void draw(); 							//Draw ColorItem onto the Canvas
	static const int width, dataX, dataY, dataHeight, dataWidth; //constants for display

private:
	ColorInt myColor;
	int myX, myY; 	//Top left coorindates
	int myId; 		//Id number, also index in Vec
	Canvas * myCan; //Handle to the Canvas
};

#endif /*COLORITEM_H_*/#include "ColorItem.h"

const int ColorItem::width = 20; //Width of each object
const int ColorItem::dataX = 200, ColorItem::dataY = 670; //Bottom left coordinates of the data area
const int ColorItem::dataHeight = 600, ColorItem::dataWidth = 200; //Dimensions of the data area

/**
 * Default constructor for the ColorItem class.
 * \return: the constructed ColorItem
 */
ColorItem::ColorItem() {
	myColor = ColorInt(0, 0, 0);
	myX = myY = myId = 0;
	myCan = NULL;
}

/**
 * \brief Explicit constructor for the ColorItem class.
 * \param can, a handle to the Canvas
 * \param color, a ColorInt to store this ColorItem's color
 * \return: the constructed ColorItem
 */
ColorItem::ColorItem(Canvas & can, ColorInt color, int index) {
	myCan = &can;
	myColor = color;
	myId = index;
	myX = ColorItem::dataX + index%(200/width) * width; // start of data + column
	myY = ColorItem::dataY - (index/(200/width) + 1) * width; // start of data + row
}

/**
 * \brief Copy constructor
 * \details Copies color, canvas, and coordinates to this ColorItem and returns this
 * \param original, the ColorItem to copy from
 * \return: this ColorItem
 */
ColorItem& ColorItem::operator=(const ColorItem& original) {
	myX = original.myX;
	myY = original.myY;
	myColor = original.myColor;
	myCan = original.myCan;
	return *this;
}

/**
 * \brief operator== checks equivalence between this and another ColorItem
 * \param other, the ColorItem for comparison
 * \return: a boolean, true if all fields are equivalent, false otherwise
 */
bool ColorItem::operator==(ColorItem& other) {
	if( myCan != other.myCan )
		return false;
	if( myX != other.myX )
		return false;
	if( myY != other.myY )
		return false;
	return true;
}

/**
 * \brief Draws the ColorItem to the Canvas
 */
void ColorItem::draw() {
	myCan->drawRectangle(myX, myY, myX+width, myY+width, myColor, true);
}
/**
 * Reader.h contains the class necessary in order to create a Reader object for the Reader-Writer visualization.
 */
#ifndef READER_H_
#define READER_H_

#include <omp.h>
//#include <tsgl.h>
#include "RWMonitor.h"
#include "WMonitor.h"
#include "RWThread.h"
#include "Thread.h"
#include "ColorItem.h"
#include "../../TSGL/tsgl.h" //remove on update of <tsgl.h>
#include "../../TSGL/Canvas.h" //remove
#include "../../TSGL/Line.h" //remove
using namespace tsgl;

/**
 * Reader class inherits from the RWThread class in order to create a Reader object. 
 * Inheritance: RWThread class.
 * Implements the run() method, which calls the read() method.
 */
class Reader : public RWThread {
public:
	Reader(); //Default constructor
	Reader(RWMonitor<ColorItem> & sharedMonitor, unsigned long id, Canvas & can); //Explicit constructor
	void read(); //Read method
	void run();  //Inheirted from RWThread class; function that the pthread should run.
};

#endif /* READER_H_ */
#include "Reader.h"

/**
 * Default-constructor for the Reader class.
 * @return: The constructed Reader object.
 */
Reader::Reader() : RWThread() { }

/**
 * Explicit-constructor for the Reader class.
 * @param: sharedData, a reference to the RWMonitor object that is shared between the Reader and Writer.
 * @param: id, an unsigned long that will be passed to the Thread() constructor that will act as the id for the Thread object.
 * @param: can, a handle to the Canvas that will be drawn on. 
 * @return: The constructed Reader object.
 */
Reader::Reader(RWMonitor<ColorItem> & sharedMonitor, unsigned long id, Canvas & can) : RWThread(sharedMonitor, id, can) {
	myX = can.getWindowWidth()-50;
	draw(myX, myY);
}

/**
 * read() method takes items from the vector and reads them while the Canvas is open.
 */
void Reader::read() {
	while(myCan->isOpen()) { //While the Canvas is still open...

		myCan->sleepFor( (rand()%20+2)/10 ); //Wait for random time

		//Request data access
		draw(myX-75, myY); //Move towards data
		while( data->getItemCount() == 0 ) { //Wait while no items available
			myCan->sleep();
		}
		data->startRead();  //Lock data for reading
		draw(myX-130, myY); //Move inside data
		
		//Read
		myColor = data->read(rand()%data->getItemCount()); //Get the color

		//Draw and erase the arrow
		int beginX = myX-150, beginY = myY, endX = myColor.getX()+(ColorItem::width/2), endY = myColor.getY()+ColorItem::width/2;
		myCan->drawLine(beginX, beginY, endX, endY, BLACK, false, true); // draw arrow to item drawn
		myCan->sleep();
		myCan->drawLine(beginX, beginY, endX, endY, recentColor, false, true); // erase the arrow

		//Redraw all ColorItems
		for(int i = 0; i < data->getItemCount(); i++ ) {
			data->read(i).draw();
		}

		//Release lock
		count++; 			//Finished another read
		draw(myX, myY); 	//Return to home location
		data->endRead(); 	//Unlock the data
	}
}

/**
 * run() method is the implemented abstract method inherited from the RWThread class. 
 * Calls the read() method.
 */
void Reader::run() {
	read();
}
/**
 * RWMonitor.h provides a RWMonitor class for the Reader-Writer visualization.
 * This class provides a superclass for the monitors with Reader or Writer preference, which are used by the threads.
 */

#ifndef RWMONITOR_H_
#define RWMONITOR_H_

#include <pthread.h>
#include <vector>
#include <iostream>
using namespace std;

template<class Item>

class RWMonitor {
public:
	RWMonitor();					//Default constructor
	RWMonitor(int max);				//Explicit constructor
	virtual void startRead() = 0;	//Must be defined by subclass
	virtual void endRead() = 0;		//Must be defined by subclass
	virtual void startWrite() = 0;	//Must be defined by subclass
	virtual void endWrite() = 0;	//Must be defined by subclass
	Item read(int index);						//Access item at index
	int getItemCount() { return vec.size(); }	//Get number of items in vector
	int getMaxCapacity() { return maxCapacity; }//Get maximum items in vector
	void write(Item it, int index);				//Set item at index

protected:
	std::vector<Item> vec;
	int activeWriters, activeReaders, waitingWriters, waitingReaders;
	int maxCapacity;
	pthread_mutex_t lock;
	pthread_cond_t okToRead, okToWrite;
};

/**
 * Default constructor for the RWMonitor class
 */
template<class Item>
RWMonitor<Item>::RWMonitor() {
	vec = vector<Item>();
	activeWriters = activeReaders = waitingWriters = waitingReaders = maxCapacity = 0;
	lock = PTHREAD_MUTEX_INITIALIZER;
	okToRead = PTHREAD_COND_INITIALIZER;
	okToWrite = PTHREAD_COND_INITIALIZER;
}

/**
 * Explicit constructor for the RWMonitor class
 */
template<class Item>
RWMonitor<Item>::RWMonitor(int max) {
	vec = vector<Item>();
	activeWriters = activeReaders = waitingWriters = waitingReaders = 0;
	lock = PTHREAD_MUTEX_INITIALIZER;
	okToRead = PTHREAD_COND_INITIALIZER;
	okToWrite = PTHREAD_COND_INITIALIZER;
	maxCapacity = max;
}

/**
 * read() returns the Item from the vector at an  index
 */
template<class Item>
Item RWMonitor<Item>::read(int index) {
	return vec[index];
}

/**
 * write() sets an item at an index
 */
template<class Item>
void RWMonitor<Item>::write(Item it, int index) {
	if( index >= vec.size() ) {
		if( index > maxCapacity )
			throw range_error("Item added beyond max capacity");
		else
			vec.push_back(it);
	} else {
		vec[index] = it;
	}
}

#endif /*RWMONITOR_H_*//**
 * RMonitor.h provides the monitor for the Reader-Writer visualization that gives preference to the Readers.
 * This class is a subclass of RWMonitor and implements its locking and unlocking virtual methods.
 */

#ifndef RMONITOR_H_
#define RMONITOR_H_

#include <pthread.h>
#include "RWMonitor.h"

template<class Item>

class RMonitor : public RWMonitor<Item> {
public:
	RMonitor() : RWMonitor<Item>() {};			//Default  constructor
	RMonitor(int max) : RWMonitor<Item>(max) {};	//Explicit constructor
	void startRead();
	void endRead();
	void startWrite();
	void endWrite();
};

/**
 * startRead() implements the abstract method in RWMonitor
 * Grants the calling thread access for reading, giving priority to readers
 */
template<class Item>
void RMonitor<Item>::startRead() {
	pthread_mutex_lock( &this->lock );
	while( this->activeWriters > 0 ) {
		++this->waitingReaders;
		pthread_cond_wait( &this->okToRead, &this->lock );
		--this->waitingReaders;
	}
	++this->activeReaders;
	pthread_mutex_unlock( &this->lock );
}

/**
 * endRead() implements the abstract method in RWMonitor
 * Releases the calling thread's read lock
 */
template<class Item>
void RMonitor<Item>::endRead() {
	pthread_mutex_lock( &this->lock );
	--this->activeReaders;
	if( this->activeReaders == 0 && this->waitingWriters > 0 ) {
		pthread_cond_signal( &this->okToWrite );
	}
	pthread_mutex_unlock( &this->lock );
}

/**
 * startWrite() implements the abstract method in RWMonitor
 * Grants the calling thread acces for writing, giving priority to readers
 */
template<class Item>
void RMonitor<Item>::startWrite() {
	pthread_mutex_lock( &this->lock );
	while( this->activeWriters > 0 || this->activeReaders > 0 || this->waitingReaders > 0) {
		++this->waitingWriters;
		pthread_cond_wait( &this->okToWrite, &this->lock );
		--this->waitingWriters;
	}
	++this->activeWriters;
	pthread_mutex_unlock( &this->lock );
}

/**
 * endWrite() implements the abstract method in RWMonitor
 * Releases the calling thread's write lock
 */
template<class Item>
void RMonitor<Item>::endWrite() {
	pthread_mutex_lock( &this->lock );
	--this->activeWriters;
	if( this->waitingReaders > 0 ) {
		pthread_cond_broadcast( &this->okToRead );
	} else if( this->waitingWriters > 0 ) {
		pthread_cond_signal( &this->okToWrite );
	}
	pthread_mutex_unlock( &this->lock );
}

#endif /*RMONITOR_H_*//**
 * WMonitor.h provides the monitor for the Reader-Writer visualization that gives preference to the Writers.
 * This class is a subclass of RWMonitor and implements its locking and unlocking virtual methods.
 */

#ifndef WMONITOR_H_
#define WMONITOR_H_

#include <pthread.h>
#include "RWMonitor.h"

template<class Item>

class WMonitor : public RWMonitor<Item> {
public:
	WMonitor() : RWMonitor<Item>() {};			//Default  constructor
	WMonitor(int max) : RWMonitor<Item>(max) {};	//Explicit constructor
	void startRead();
	void endRead();
	void startWrite();
	void endWrite();
};

/**
 * startRead() implements the abstract method in RWMonitor
 * Grants the calling thread access for reading, giving priority to writers
 */
template<class Item>
void WMonitor<Item>::startRead() {
	pthread_mutex_lock( &this->lock );
	while( this->activeWriters > 0 || this->waitingWriters > 0) {
		++this->waitingReaders;
		pthread_cond_wait( &this->okToRead, &this->lock );
		--this->waitingReaders;
	}
	++this->activeReaders;
	pthread_mutex_unlock( &this->lock );
}

/**
 * endRead() implements the abstract method in RWMonitor
 * Releases the calling thread's read lock
 */
template<class Item>
void WMonitor<Item>::endRead() {
	pthread_mutex_lock( &this->lock );
	--this->activeReaders;
	if( this->activeReaders == 0 && this->waitingWriters > 0 ) {
		pthread_cond_signal( &this->okToWrite );
	}
	pthread_mutex_unlock( &this->lock );
}

/**
 * startWrite() implements the abstract method in RWMonitor
 * Grants the calling thread acces for writing, giving priority to writers
 */
template<class Item>
void WMonitor<Item>::startWrite() {
	pthread_mutex_lock( &this->lock );
	while( this->activeWriters > 0 || this->activeReaders > 0) {
		++this->waitingWriters;
		pthread_cond_wait( &this->okToWrite, &this->lock );
		--this->waitingWriters;
	}
	++this->activeWriters;
	pthread_mutex_unlock( &this->lock );
}

/**
 * endWrite() implements the abstract method in RWMonitor
 * Releases the calling thread's write lock
 */
template<class Item>
void WMonitor<Item>::endWrite() {
	pthread_mutex_lock( &this->lock );
	--this->activeWriters;
	if( this->waitingWriters > 0 ) {
		pthread_cond_signal( &this->okToWrite );
	} else if( this->waitingReaders > 0 ) {
		pthread_cond_broadcast( &this->okToRead );
	}
	pthread_mutex_unlock( &this->lock );
}

#endif /*WMONITOR_H_*/#include "RWThread.h"

/**
 * Default-constructor for the RWThread class.
 * @return: The constructed Reader object.
 */
RWThread::RWThread() : Thread() {
	myColor = ColorItem();
	data = NULL;
	myCan = NULL;
	count = 0;
	recentX = recentY = myX = myY = 0;
}

/**
 * Explicit-constructor for the RWThread class.
 * @param: sharedMonitor, a reference to the RWMonitor object that is shared between the Reader and Writer.
 * @param: id, an unsigned long that will be passed to the Thread() constructor that will act as the id for the Thread object.
 * @param: can, a handle to the Canvas that will be drawn on and will determine whether or not to continue consuming object from the Queue. 
 * @return: The constructed RWThread object.
 */
RWThread::RWThread(RWMonitor<ColorItem> & sharedMonitor, unsigned long id, Canvas & can) : Thread(id) {
	count = recentX = recentY = 0;
	myColor = ColorItem();
	recentColor = can.getBackgroundColor();
	data = &sharedMonitor;	//Get the handle to the Monitor
	myCan = &can;			//Get the handle to the Canvas
	myY = 50 * (id + 1) + 60;
	myX = 0; //Set in subclass constructor
}

/**
 * draw() method draws the RWThread onto the Canvas.
 * @param: x, the x coordinate of the drawing
 * @param: y, the y coordinate of the drawing
 */
void RWThread::draw(int x, int y) {
	myCan->sleep();
	erase();
	recentColor = myCan->getPoint(x, y);
	myCan->drawCircle(x, y, 20, 32, myColor.getColor());
	int textSize = 20;
	if( count > 99 ) textSize = 15;
	if( count > 999) textSize = 10;
	myCan->drawText( to_string(count), x-15, y+5, textSize, BLACK);
	recentX = x;
	recentY = y;
}

/**
 * erase() method erases the RWTHread from the Canvas
 */
void RWThread::erase() {
	myCan->drawCircle(recentX, recentY, 20, 32, recentColor);
}/**
 * Thread.h contains the abstract class necessary in order to have pthreads for Readers and Writers.
 * Adapted from: http://jrdodds.blogs.com/blog/2006/06/encapsulating_a.html
 *				 https://slworkthings.wordpress.com/2009/11/10/a-pthread-wrapper-class-part-1/
 *				 https://cppcodetips.wordpress.com/2013/12/05/pthread-c-wrapper/
 *				 http://peter.bourgon.org/blog/2010/10/27/who-needs-boost-a-simple-pthreads-wrapper.html 
 *				 Practical Guide To Pthread Programming in C++ By Swaminathan Bhaskar (pdf)
 */
#ifndef THREAD_H_
#define THREAD_H_

#include <pthread.h>
#include <iostream>

/**
 * The Thread class encapsulates the details of creating a pthread.
 * It is abstract; cannot be instantiated. 
 */
class Thread {
public:
	Thread();  //Default-constructor
	Thread(unsigned long id);  //Constructor
	unsigned long getId() const;  //Accessor for the id
	void start();  //Create the pthread and run the corresponding method
	virtual void run() = 0;  //Needs to be defined by the inheriting subclass
	void join();   //Join at the end
	
protected:
	static void* threadFunction(void* obj); //The function that the pthread will run

private:
	unsigned long myId;   //Id for the Thread object
	pthread_t myThread;   //pthread
};

#endif /* THREAD_H_ */#include "Thread.h"

/**
 * Default-constructor for a Thread object.
 * @return: The constructed Thread object with id == 0.
 */
Thread::Thread() {
	myId = 0;
}

/**
 * Explicit-constructor for a Thread object.
 * @param: myId, an unsigned long representing the id for the Thread object.
 * @return: The constructed Thread object with id == myId.
 */
Thread::Thread(unsigned long id) {
	myId = id;
}

/**
 * threadFunction() is the function that the pthread should run as soon as it is created. 
 * @param: obj, a void* that will be statically casted into a Thread object. 
 *              It will run the run() function, which will be defined by the inheriting subclass.
 ^ @return: NULL.
 */
void* Thread::threadFunction(void* obj) {
	Thread * thread = static_cast<Thread*>(obj);
	thread->run();  //This NEEDS to be defined by the subclass
	pthread_exit(0); //Exit upon completion
}

/**
 * start() function creates the pthread inside of the Thread class.
 */
void Thread::start() {
	pthread_create(&myThread, NULL, threadFunction, this);
	pthread_setcancelstate(PTHREAD_CANCEL_ENABLE,NULL);
}

/**
 * join() function cancels the pthread inside of the Thread class.
 */
void Thread::join() {
	pthread_cancel(myThread); // solution to hanging process bug
}

/**
 * getId() is the accessor function for the id of the Thread object.
 * @return: myId, an unsigned long representing the id of the Thread object.
 */
unsigned long Thread::getId() const {
	return myId;
}
/**
 * Writer.h contains the class necessary in order to create a Writer object for the Reader-Writer visualization.
 */
#ifndef WRITER_H_
#define WRITER_H_

//#include <omp.h>
//#include <tsgl.h>
#include "RWMonitor.h"
#include "WMonitor.h"
#include "RWThread.h"
#include "Thread.h"
#include "ColorItem.h"
#include "../../TSGL/tsgl.h"
#include "../../TSGL/Canvas.h"
#include "../../TSGL/Line.h"
using namespace tsgl;

/**
 * Writer class creates a Writer object and inherits from the RWThread class.	
 * Inheritance: RWThread class.
 * Implements the abstract run() method from the Thread class so that the pthread runs the write() method.
 */
class Writer : public RWThread {
public:
	Writer(); //Default constructor
	Writer(RWMonitor<ColorItem> & sharedMonitor, unsigned long id, Canvas & can); //Explicit constructor
	void write(); //Generate color data
	void run();   //Implementation of run() method for pthread
private:
	ColorInt randColor();
	int randIndex();
};

#endif /* WRITER_H_ */
#include "Writer.h"

/**
 * Default-constructor for the Writer class.
 * @return: The constructed Writer object.
 */
Writer::Writer() : RWThread() {
}

/**
 * Explicit-constructor for the Writer class.
 * @param: sharedMonitor, a reference to the RWMonitor object that is shared between the Reader and Writer.
 * @param: id, an unsigned long that will be passed to the Thread() constructor that will act as the id for the Thread object.
 * @param: can, a handle to the Canvas that will be drawn on. 
 * @return: The constructed Writer object.
 */
Writer::Writer(RWMonitor<ColorItem> & sharedMonitor, unsigned long id, Canvas & can) : RWThread(sharedMonitor, id, can) {
	myColor = ColorItem(*myCan, Colors::highContrastColor(id), 0);
	myX = 50; //Set the x-coordinate to 50
	draw(myX, myY);
}

/**
 * write() method generates random colors and adds them in the shared data while the Canvas is open.
 */
void Writer::write() {
	while (myCan->isOpen()) {  //While the Canvas is still open...

		myCan->sleepFor( (rand()%20+2)/10 ); //Wait for a random time
		
		//Request data access
		draw(myX+75, myY);  //Move in toward data
		data->startWrite(); //Lock data for writing

		//Create and write
		draw(myX+130, myY); //Move inside data
		ColorItem color(*myCan, randColor(), randIndex()); //Make random color at random index
		data->write(color, color.getId());  // Write the item to the data
		color.draw(); //Display the color just written

		//Draw an arrow down to the item
		int endX = color.getX()+(ColorItem::width/2), endY = color.getY()+ColorItem::width/2, beginX = myX+150, beginY = myY;
		myCan->drawLine(beginX, beginY, endX, endY, BLACK, false, true); // draw arrow to item drawn
		myCan->sleep();
		myCan->drawLine(beginX, beginY, endX, endY, recentColor, false, true); // erase the arrow

		//Redraw all ColorItems
		for( int i = 0; i < data->getItemCount(); i++) {
			data->read(i).draw();
		}
		
		//Release lock
		count++; 			//Finished another write
		draw(myX, myY); 	//Return to home location
		data->endWrite(); 	//Unlock the data for writing
	}
}

/**
 * newColor() generates a new random color for writing.
 */
ColorInt Writer::randColor() {
	int red = rand() % 255;
	int green = rand() % 255;
	int blue = rand() % 255;
	return ColorInt(red, green, blue);
}

/**
 * randIndex() generates an index number to add a new item
 */
int Writer::randIndex() {
	int i = rand()%(data->getMaxCapacity()); // random index between 0 and the number of items in data
		if( i > data->getItemCount() )
			i = data->getItemCount();
	return i;
}

/**
 * run() method is the implemented abstract method inherited from the RWThread class. 
 * Calls the write() method. 
 */
void Writer::run() {
	write();
}
