<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TSGL: Bringing-It-All-Together</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TSGL
   </div>
   <div id="projectbrief">A thread-safe graphics library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Bringing-It-All-Together </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>End of the line, folks!</p>
<p><em><b>Linux/Mac users:</b></em> Follow the steps from the previous tutorials. Name the folder "Tutorial9" and the file "thread.cpp". Replace "program" in the "TARGET" line of the Makefile with "thread".</p>
<p><em><b>Windows users:</b></em> Follow the steps from the previous tutorials. Name the Solution folder "Tutorial9" and the Visual Studio project "Threads". After adding the Property sheet, name the .cpp file "thread.cpp".</p>
<p><em><b>All three platforms:</b></em> Follow the steps in the [[Building Programs]] page on how to compile and run the program (Linux/Mac users, this is a single-file program).</p>
<p>We've seen how TSGL draws shapes, handles colors, text, I/O events, and command-line arguments.</p>
<p>Now...how exactly does threading come into play in this library?</p>
<p>TSGL does stand for "Thread-Safe Graphics Library."</p>
<p>How can we utilize threading in our drawings?</p>
<p>Simple. Let's first write some skeleton code:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;tsgl.h&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>tsgl;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  RasterCanvas c(100, 100, 500, 500, <span class="stringliteral">&quot;Threading&quot;</span>, FRAME);</div>
<div class="line">  c.start();</div>
<div class="line">  c.wait();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Compile and run. A black screen should appear.</p>
<p>When your program includes the header file <code><a class="el" href="tsgl_8h_source.html">tsgl.h</a></code>, it also includes the header file (<code>omp.h</code>) needed in order to use OpenMP library functions such as <code>omp_get_num_threads()</code> and <code>omp_get_thread_num()</code> (which gets the number of threads spawned and the id number of a thread, respectively). It also allows us to utilize the <code>#pragma omp</code> directive, which enables us to write blocks of code that should be executed in parallel.</p>
<p>We're going to use the RasterCanvas because we'll be drawing points.</p>
<p>Now, we've seen drawing loops in the tutorial, [[Animation Loops]], but we aren't going to be adding one to this code. Instead, we are going to do something a little differently:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;tsgl.h&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>tsgl;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> drawTutorial(RasterCanvas &amp; can) {</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  RasterCanvas c(100, 100, 500, 500, <span class="stringliteral">&quot;Threading&quot;</span>, FRAME);</div>
<div class="line">  c.start();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span> startTime = omp_get_wtime();</div>
<div class="line">  drawTutorial(c);</div>
<div class="line"> </div>
<div class="line">  printf(<span class="stringliteral">&quot;\nTime to color pixels: %f\n&quot;</span>, omp_get_wtime() - startTime);</div>
<div class="line">  c.wait();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Let us explain what we did differently. We added a function stub ( <code>drawTutorial()</code> ) that takes in a reference to a Canvas object. We also added timing statements: <code>double startTime = omp_get_wtime();</code>, <code>printf("\nTime to color pixels: %f\n", omp_get_wtime() - startTime);</code>. These statements will keep track of how long our drawing took when we call our <code>drawTutorial()</code> function.</p>
<p>Next, let's define the function so that it actually draws something onto the passed Canvas:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;tsgl.h&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>tsgl;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> drawTutorial(RasterCanvas &amp; can) {</div>
<div class="line">   <a class="code" href="structtsgl_1_1_color_float.html">ColorFloat</a> color = RED;</div>
<div class="line">   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i = 0; i &lt; can.getWindowWidth(); i++) {</div>
<div class="line">      can.sleep();</div>
<div class="line">      <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j = 0; j &lt; can.getWindowHeight(); j++) {</div>
<div class="line">         can.drawPoint(i, j, color);</div>
<div class="line">      }</div>
<div class="line">   }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  RasterCanvas c(100, 100, 500, 500, <span class="stringliteral">&quot;Threading&quot;</span>, FRAME);</div>
<div class="line">  c.start();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span> startTime = omp_get_wtime();</div>
<div class="line">  drawTutorial(c);</div>
<div class="line"> </div>
<div class="line">  printf(<span class="stringliteral">&quot;\nTime to color pixels: %f\n&quot;</span>, omp_get_wtime() - startTime);</div>
<div class="line">  c.wait();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Re-compile and run. The screen should now be red. It took 8.319619 seconds to color all of the pixels on our machine. (Note that we are using the <code>can.sleep()</code> call to slow the computation down, so that you can see the main thread coloring the pixels.)</p>
<p>The main function passes our created RasterCanvas, <code>c</code>, to the <code>drawTutorial()</code> function. That function colors each pixel of its <code>can</code> parameter red, and since <code>can</code> is a reference parameter for our argument <code>c</code>, this colors each pixel of <code>c</code> red.</p>
<p>So where do threads come in?</p>
<p>As it stands, we just have the main thread creating and initializing a Canvas object, and then coloring it red in the <code>drawTutorial()</code> function. To spread the work of coloring the Canvas across multiple threads, we can add a parallel block and parallel <code>for</code> loop to our function:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;tsgl.h&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>tsgl;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> drawTutorial(RasterCanvas &amp; can) {</div>
<div class="line">   <a class="code" href="structtsgl_1_1_color_float.html">ColorFloat</a> color = RED;</div>
<div class="line"><span class="preprocessor">   #pragma omp parallel</span></div>
<div class="line">   {</div>
<div class="line"><span class="preprocessor">     #pragma omp for</span></div>
<div class="line">     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i = 0; i &lt; can.getWindowWidth(); i++) {</div>
<div class="line">        can.sleep();</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j = 0; j &lt; can.getWindowHeight(); j++) {</div>
<div class="line">           can.drawPoint(i, j, color);</div>
<div class="line">        }</div>
<div class="line">     }</div>
<div class="line">   }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  omp_set_num_threads(4);  <span class="comment">//Set the number of threads to use</span></div>
<div class="line">  RasterCanvas c(100, 100, 500, 500, <span class="stringliteral">&quot;Threading&quot;</span>, FRAME);</div>
<div class="line">  c.start();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span> startTime = omp_get_wtime();</div>
<div class="line">  drawTutorial(c);</div>
<div class="line"> </div>
<div class="line">  printf(<span class="stringliteral">&quot;\nTime to color pixels: %f\n&quot;</span>, omp_get_wtime() - startTime);</div>
<div class="line">  c.wait();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Re-compile and run. The screen should still be red. It took 2.080817 seconds to color all of the pixels with four threads (about 1/4 of the original time) on our machine.</p>
<p>Let's take a look at the parallel block:</p>
<div class="fragment"><div class="line">ColorFloat color = RED;</div>
<div class="line"><span class="preprocessor">#pragma omp parallel</span></div>
<div class="line">{</div>
<div class="line"><span class="preprocessor">  #pragma omp for</span></div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i = 0; i &lt; can.getWindowWidth(); i++) {</div>
<div class="line">     can.sleep();</div>
<div class="line">     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j = 0; j &lt; can.getWindowHeight(); j++) {</div>
<div class="line">        can.drawPoint(i, j, color);</div>
<div class="line">     }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>color</code> is set to <code>RED</code>, and a parallel block is made with <code>4</code> threads (see the <code>omp_set_num_threads()</code> function in the main method before we create a Canvas).</p>
<p>Because of the <code>omp_set_num_threads(4);</code> statement in the <code>main()</code> function, the <code>#pragma omp parallel</code> directive causes the main thread to fork 3 new threads. Each of the four threads will then perform the statements in the block that follows the <code>pragma</code>. The <code>#pragma omp for</code> directive then divides up the iterations of the <code>for</code> loop that follows it among those four threads. Since the inner loop colors the pixels <code>RED</code>, all of the threads end up coloring their pixels the same color.</p>
<p>It also speeds up the coloring of the pixels in proportion to the number of threads being used; in this case, four threads were used, so the time to color all of the pixels red was about 1/4 of the original time.</p>
<p>This is nice and all....but we can't really visualize the four threads coloring different pixels. We know they are coloring them <code>RED</code>, but which ones?</p>
<p>Let's add some more code to better visualize this:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;tsgl.h&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>tsgl;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> drawTutorial(RasterCanvas &amp; can) {</div>
<div class="line">  <span class="comment">//Parallel block</span></div>
<div class="line"><span class="preprocessor">  #pragma omp parallel</span></div>
<div class="line">  {</div>
<div class="line">    <span class="comment">//Current thread id &amp; number of threads</span></div>
<div class="line">    <span class="keywordtype">float</span> tid = omp_get_thread_num();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//Give it a color</span></div>
<div class="line">    <a class="code" href="structtsgl_1_1_color_float.html">ColorFloat</a> color = <a class="code" href="classtsgl_1_1_colors.html#a93d3fc815542e586dbc1ecf3e984e0b6">Colors::highContrastColor</a>(tid);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//Color the pixels</span></div>
<div class="line"><span class="preprocessor">    #pragma omp for</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i = 0; i &lt; can.getWindowWidth(); i++) {</div>
<div class="line">        can.sleep();</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j = 0; j &lt; can.getWindowHeight(); j++) {</div>
<div class="line">            can.drawPoint(i, j, color);</div>
<div class="line">          }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  omp_set_num_threads(4);  <span class="comment">//Set the number of threads to use</span></div>
<div class="line">  RasterCanvas c(100, 100, 500, 500, <span class="stringliteral">&quot;Threading&quot;</span>, FRAME);</div>
<div class="line">  c.start();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span> startTime = omp_get_wtime();</div>
<div class="line">  drawTutorial(c);</div>
<div class="line"> </div>
<div class="line">  printf(<span class="stringliteral">&quot;\nTime to color pixels: %f\n&quot;</span>, omp_get_wtime() - startTime);</div>
<div class="line">  c.wait();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Recompile and run. There should now be four differently colored sections! (It took 2.079545 seconds to color the the screen four different colors on our machine!)</p>
<p>Since the changes were made only to <code>drawTutorial()</code>, let's take a closer look at that function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> drawTutorial(RasterCanvas &amp; can) {</div>
<div class="line">  <span class="comment">//Parallel block</span></div>
<div class="line"><span class="preprocessor">  #pragma omp parallel</span></div>
<div class="line">  {</div>
<div class="line">    <span class="comment">//Current thread id &amp; number of threads</span></div>
<div class="line">    <span class="keywordtype">float</span> tid = omp_get_thread_num();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//Give it a color</span></div>
<div class="line">    ColorFloat color = Colors::highContrastColor(tid);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//Color the pixels</span></div>
<div class="line"><span class="preprocessor">    #pragma omp for</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i = 0; i &lt; can.getWindowWidth(); i++) {</div>
<div class="line">        can.sleep();</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j = 0; j &lt; can.getWindowHeight(); j++) {</div>
<div class="line">            can.drawPoint(i, j, color);</div>
<div class="line">          }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>This function allows us to see the threads coloring different sections of the Canvas and thereby make it <em><b>MUCH</b></em> easier to visualize.</p>
<p>Next, let's add support for command-line arguments so that we can control the number of threads being used:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;tsgl.h&gt;</span></div>
<div class="line"><span class="keyword">using namespace </span>tsgl;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> drawTutorial(RasterCanvas &amp; can) {</div>
<div class="line">  <span class="comment">//Parallel block</span></div>
<div class="line"><span class="preprocessor">  #pragma omp parallel</span></div>
<div class="line">  {</div>
<div class="line">    <span class="comment">//Current thread id &amp; number of threads</span></div>
<div class="line">    <span class="keywordtype">float</span> tid = omp_get_thread_num();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//Give it a color</span></div>
<div class="line">    <a class="code" href="structtsgl_1_1_color_float.html">ColorFloat</a> color = <a class="code" href="classtsgl_1_1_colors.html#a93d3fc815542e586dbc1ecf3e984e0b6">Colors::highContrastColor</a>(tid);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//Color the pixels</span></div>
<div class="line"><span class="preprocessor">    #pragma omp for</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i = 0; i &lt; can.getWindowWidth(); i++) {</div>
<div class="line">        can.sleep();</div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> j = 0; j &lt; can.getWindowHeight(); j++) {</div>
<div class="line">            can.drawPoint(i, j, color);</div>
<div class="line">          }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">//Adding command-line argument support...</span></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[]) {</div>
<div class="line">  <span class="keywordtype">int</span> width = (argc &gt; 1) ? atoi(argv[1]) : 700;</div>
<div class="line">  <span class="keywordtype">int</span> height = (argc &gt; 2) ? atoi(argv[2]) : 800;</div>
<div class="line">  <span class="keywordflow">if</span>(width &lt;= 0 || height &lt;= 0) {</div>
<div class="line">    width = height = 900;</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">//Threads...</span></div>
<div class="line">  <span class="keywordtype">int</span> threads = (argc &gt; 3) ? atoi(argv[3]) : omp_get_num_procs();</div>
<div class="line">  <span class="keywordflow">if</span>(threads &lt;= 0) {</div>
<div class="line">    <span class="comment">//omp_get_num_procs() gets the number of available processors on your system</span></div>
<div class="line">    threads = omp_get_num_procs();</div>
<div class="line">  }</div>
<div class="line">  omp_set_num_threads(threads); <span class="comment">//Use the number of threads passed via command-line</span></div>
<div class="line">  RasterCanvas c(100, 100, width, height, <span class="stringliteral">&quot;Threading&quot;</span>, FRAME);</div>
<div class="line">  c.start();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">double</span> startTime = omp_get_wtime();</div>
<div class="line">  drawTutorial(c);</div>
<div class="line"> </div>
<div class="line">  printf(<span class="stringliteral">&quot;\nTime to color pixels: %f\n&quot;</span>, omp_get_wtime() - startTime);</div>
<div class="line">  c.wait();</div>
<div class="line">}</div>
</div><!-- fragment --><p>We just added support for three command-line arguments: the width and height of the Canvas, and the number of threads to use in rendering. We added checks to make sure that they were valid arguments, and then we used the first two as the width and height of the Canvas.</p>
<p>We are then passing the third argument, the number of threads to use, into <code>omp_set_num_threads()</code> so that we can use that number in rendering.</p>
<p>Before continuing, note that we did not use an animation loop because our <code>drawTutorial()</code> function is not animating anything — it is just creating an inanimate drawing on the Canvas. We only need to use animation loops when we are animating something.</p>
<p>Compile and run the program, passing these command-line arguments: 700, 700, 10. There should now be 10 differently colored sections of the Canvas! (It took 0.830523 seconds to color the 10 different sections on our machine!)</p>
<p>Since we used 10 threads, the time should be about 1/10 of the original time. Using n threads, it should take about 1/n seconds of the original time (with one thread) to draw, provided (a) we have enough work for the threads to do, (b) the work of each thread is independent of the others, and (c) there are enough cores available for them to run independently.</p>
<p>In sum, OpenMP makes it easy to add multithreading to speed up a sequential program, and TSGL can be used to visualize what each thread is doing. You can use command-line arguments to control the number of threads; you can also a function that draws a particular drawing (with or without multithreading).</p>
<p>That concludes this tutorial!</p>
<p>We hope that these tutorial pages help you get started with TSGL, and that you make some amazing creations with this library! </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="aclasstsgl_1_1_colors_html_a93d3fc815542e586dbc1ecf3e984e0b6"><div class="ttname"><a href="classtsgl_1_1_colors.html#a93d3fc815542e586dbc1ecf3e984e0b6">tsgl::Colors::highContrastColor</a></div><div class="ttdeci">static ColorFloat highContrastColor(unsigned int index, int offset=0)</div><div class="ttdoc">Returns an HSV color with high contrast.</div><div class="ttdef"><b>Definition:</b> Color.cpp:553</div></div>
<div class="ttc" id="astructtsgl_1_1_color_float_html"><div class="ttname"><a href="structtsgl_1_1_color_float.html">tsgl::ColorFloat</a></div><div class="ttdoc">Floating point RGBA color struct.</div><div class="ttdef"><b>Definition:</b> Color.h:32</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jul 26 2021 14:23:49 for TSGL by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
